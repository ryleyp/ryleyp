To run this code, build the makefile using the 'make all' command by opening the file in a Linux command terminal. After this, the command line will ask for an file name input. There are a few test case files included, and these can be used by entering in 'testcase_3.in' 

There are 6 types of loop orderings that can be implemented in matrix multiplication. These loops allow the user to vary the order of operations (either row-wise, column-wise, or location-wise) and decide how matrix elements are calculated to reach a more efficient algorithm or to avoid any possible data misses within an iteration. Within these 6 types, there are pairs that essentially offer the same method of operation, reducing the overall number of combinations to 3. Each of these combinations deal with two inputted matrices (A and B) and a result/product matrix (C). The first pair or iteration is the ijk/jik mode of operation. This pair iterates through j and i to go through a specific row (i) for A and a specific column (j) for B in order to find a fixed location to calculate the product for C (i,j). The difference between these two is that ijk iterates through i first and the jik iterates through j first. This pair is the most efficient and performs the fastest but has a high rate of misses at 1.25 per iteration. The next pairing is kij and ikj. This pairing uses a fixed location for A (i,k) and uses row-wise operations for B (row k) and C(row i) in order to find the product. To do this, two external for loops are formed for i and k, which are used to find the exact location for A. Then, another for loop is added underneath to iterate through j to calculate the product of the matrices and store it in C. This pairing has the lowest number of misses per inner loop. The final pairing is the jki/kji pairing. This pair iterates through j and k to go through a specific location (k,j) for B and a specific column (k) for A in order to complete a column-wise operation for C (j). This pairing is the slowest and has about 2 misses per inner loop iteration.

To help avoid these misses and to speed up our program, we were asked to implement cache blocking on the most efficient pairing (ijk/jik). To do this, we would need to parse out matrices into smaller submatrices to load directly into the cache. Once this submatrix is in the cache, normal multiplication operations are performed on it to implement both spatial and temporal locality. This test case is seen in the BIJK output.
